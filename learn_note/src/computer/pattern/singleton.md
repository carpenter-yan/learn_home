# 单例

## 5种实现  
饿汉式  
饱汉式  
双重校验锁  
静态内部类  
枚举  

懒汉式（包含线程安全和不安全）都比较少用；饿汉式和双检锁都可以使用，可根据具体情况自主选择；在要明确实现lazy loading效果时，可以考虑静态内部类的实现方式；若涉及到反序列化创建对象时，大家也可以尝试使用枚举方式。  

枚举类型在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。  

普通的Java类的反序列化过程中，会通过反射调用类的默认构造函数来初始化对象。所以，即使单例中构造函数是私有的，也会被反射给破坏掉。由于反序列化后的对象是重新new出来的，所以这就破坏了单例。(使用双重校验锁实现的单例其实是存在一定问题的，就是这种单例有可能被序列化锁破坏)  

普通类的反序列化是通过反射实现的，枚举类的反序列化不是通过反射实现的。所以，枚举类也就不会发生由于反序列化导致的单例破坏问题。  
